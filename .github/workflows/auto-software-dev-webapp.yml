name: ASDW Orchestrator

# auto-software-dev-webapp ラベル付き Issue の opened/labeled/closed イベントで起動
on:
  issues:
    types: [opened, labeled, closed]

permissions:
  issues: write
  contents: read

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    concurrency:
      group: asdw-orchestrator-${{ github.event.issue.number }}
      cancel-in-progress: false
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      COPILOT_PAT: ${{ secrets.COPILOT_PAT }}
      REPO: ${{ github.repository }}

    steps:
      # ----------------------------------------------------------------
      # 1. 実行ゲート: auto-software-dev-webapp ラベルあり + asd:initialized なし
      # ----------------------------------------------------------------
      - name: 実行ゲートチェック
        id: gate
        env:
          ISSUE_LABELS: ${{ toJson(github.event.issue.labels.*.name) }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          EVENT_ACTION: ${{ github.event.action }}
          LABEL_NAME: "${{ github.event.label.name || '' }}"
        run: |
          set -euo pipefail

          # Issue title を API 経由で安全に取得（YAML 展開問題を回避）
          ISSUE_TITLE=$(curl -sf \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${REPO}/issues/${ISSUE_NUMBER}" \
            | python3 -c "import sys,json; print(json.load(sys.stdin).get('title',''))")
          export ISSUE_TITLE

          # labeled イベントの処理: asd:done のみ状態遷移、それ以外は全スキップ
          if [[ "${EVENT_ACTION}" == "labeled" ]]; then
            if [[ "${LABEL_NAME}" == "asd:done" ]]; then
              echo "mode=state_transition" >> "$GITHUB_OUTPUT"
              echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "asd:done 以外の labeled イベント（${LABEL_NAME}）。スキップ。"
              echo "mode=skip" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          # closed イベントの処理
          if [[ "${EVENT_ACTION}" == "closed" ]]; then
            # [ASDW] Sub Issue のみ処理
            if [[ "${ISSUE_TITLE}" =~ ^\[ASDW\] ]]; then
              # 既に asd:done がついていれば labeled イベントが後で来るのでスキップ
              has_done=$(echo "${ISSUE_LABELS}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          labels = json.load(sys.stdin)
          print('true' if 'asd:done' in labels else 'false')
          PY
              )
              if [[ "${has_done}" == "true" ]]; then
                echo "既に asd:done ラベル済み。closed イベントをスキップ（labeled イベントで処理済み or 処理中）。"
                echo "mode=skip" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              # asd:done がない場合は closed イベントから直接 state_transition を起動
              echo "mode=state_transition" >> "$GITHUB_OUTPUT"
              echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "closed イベント: [ASDW] Sub Issue 以外のためスキップ。"
              echo "mode=skip" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          # [ASDW] プレフィックスを持つ Sub Issue は初期化をスキップ
          # （Sub Issue の opened イベントによる再帰的な初期化を防止）
          if [[ "${ISSUE_TITLE}" =~ ^\[ASDW\] ]]; then
            echo "[ASDW] Sub Issue のため初期化対象外。スキップ。"
            echo "mode=skip" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # auto-software-dev-webapp ラベルを持つか確認
          has_asdw=$(echo "${ISSUE_LABELS}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          labels = json.load(sys.stdin)
          print('true' if 'auto-software-dev-webapp' in labels else 'false')
          PY
          )

          if [[ "${has_asdw}" != "true" ]]; then
            echo "auto-software-dev-webapp ラベルなし。スキップ。"
            echo "mode=skip" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # asd:initialized / asd:ready / asd:running / asd:done / asd:blocked
          # のいずれかを持つ場合はスキップ（冪等化・Sub Issue への誤再初期化防止）
          has_init=$(echo "${ISSUE_LABELS}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          labels = json.load(sys.stdin)
          skip_labels = {'asd:initialized', 'asd:ready', 'asd:running', 'asd:done', 'asd:blocked'}
          print('true' if any(l in skip_labels for l in labels) else 'false')
          PY
          )

          if [[ "${has_init}" == "true" ]]; then
            echo "asd:* ラベル済み。スキップ（冪等化）。"
            echo "mode=skip" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "mode=initialize" >> "$GITHUB_OUTPUT"
          echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------
      # 2. ラベル bootstrap
      # ----------------------------------------------------------------
      - name: ラベル bootstrap
        if: steps.gate.outputs.mode == 'initialize'
        run: |
          set -euo pipefail

          # ラベルを作成する関数（422 = 既存の場合は無視）
          create_label() {
            local name="$1"
            local color="$2"
            local desc="$3"
            local http_code
            http_code=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/labels" \
              -d "{\"name\":\"${name}\",\"color\":\"${color}\",\"description\":\"${desc}\"}")
            if [[ "${http_code}" == "201" ]]; then
              echo "ラベル作成: ${name}"
            elif [[ "${http_code}" == "422" ]]; then
              echo "ラベル既存（スキップ）: ${name}"
            else
              echo "ラベル作成エラー: ${name} HTTP ${http_code}"
            fi
            sleep 1
          }

          create_label "auto-software-dev-webapp" "1D76DB" "run full web app development pipeline on Azure"
          create_label "asd:initialized"           "C5DEF5" ""
          create_label "asd:ready"                 "0075CA" ""
          create_label "asd:running"               "E4E669" ""
          create_label "asd:done"                  "0E8A16" ""
          create_label "asd:blocked"               "D73A4A" ""

      # ----------------------------------------------------------------
      # 3. Issue body パース & Step Issue 生成
      # ----------------------------------------------------------------
      - name: Issue 初期化とStep Issue 生成
        if: steps.gate.outputs.mode == 'initialize'
        env:
          ISSUE_NUMBER: ${{ steps.gate.outputs.issue_number }}
        run: |
          set -euo pipefail

          # Issue body を API 経由で安全に取得（YAML 展開問題を回避）
          ISSUE_BODY=$(curl -s \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${REPO}/issues/${ISSUE_NUMBER}" \
            | python3 -c "import sys,json; print(json.load(sys.stdin).get('body',''))")
          export ISSUE_BODY

          if [[ -z "${COPILOT_PAT}" ]]; then
            echo "WARNING: COPILOT_PAT が設定されていません。Copilot アサインは全てスキップされます。" >&2
          fi

          ROOT_ISSUE="${ISSUE_NUMBER}"

          # ---- ユーティリティ関数 ----

          # リトライ付き curl
          api_call() {
            local method="$1"; shift
            local url="$1"; shift
            local data="${1:-}"
            local max_retry=5
            local wait=1
            local http_code response body

            for i in $(seq 1 "${max_retry}"); do
              if [[ -n "${data}" ]]; then
                response=$(curl -s -w "\n%{http_code}" \
                  -X "${method}" \
                  -H "Authorization: Bearer ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  -H "Content-Type: application/json" \
                  "${url}" \
                  -d "${data}")
              else
                response=$(curl -s -w "\n%{http_code}" \
                  -X "${method}" \
                  -H "Authorization: Bearer ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "${url}")
              fi
              http_code=$(echo "${response}" | tail -1)
              body=$(echo "${response}" | head -n -1)
              if [[ "${http_code}" =~ ^2 ]]; then
                echo "${body}"
                return 0
              fi
              echo "API エラー: HTTP ${http_code}、${wait}秒後にリトライ (${i}/${max_retry})" >&2
              sleep "${wait}"
              wait=$((wait * 2))
            done
            echo "API 呼び出し失敗: ${method} ${url}" >&2
            return 1
          }

          # Issue 作成
          create_issue() {
            local title="$1"
            local body="$2"
            local labels_json="$3"
            local data
            data=$(python3 - "${title}" "${body}" "${labels_json}" <<'PY'
          import json, sys
          title = sys.argv[1]
          body  = sys.argv[2]
          labels = json.loads(sys.argv[3])
          print(json.dumps({'title': title, 'body': body, 'labels': labels}))
          PY
          )
            api_call POST "https://api.github.com/repos/${REPO}/issues" "${data}"
          }

          # Sub Issue 紐付け
          link_sub_issue() {
            local parent_num="$1"
            local child_id="$2"
            local data="{\"sub_issue_id\":${child_id}}"
            api_call POST \
              "https://api.github.com/repos/${REPO}/issues/${parent_num}/sub_issues" \
              "${data}" || true
            sleep 1
          }

          # ラベル付与
          add_label() {
            local issue_num="$1"
            local label="$2"
            api_call POST \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/labels" \
              "{\"labels\":[\"${label}\"]}" > /dev/null
            sleep 1
          }

          # アサイン
          assign_copilot() {
            local issue_num="$1"
            local custom_agent="${2:-}"
            local base_branch="${3:-main}"
            local custom_instructions="${4:-}"

            echo "=== Copilot アサイン開始: Issue #${issue_num} ==="
            echo "  custom_agent: ${custom_agent}"
            echo "  base_branch: ${base_branch}"

            # 冪等化ガード: 既に copilot-swe-agent がアサインされている場合はスキップ
            local current_assignees
            current_assignees=$(curl -s \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}" \
              | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              if not isinstance(d, dict):
                  print('false')
                  sys.exit(0)
              assignees = [a.get('login', '') for a in d.get('assignees', [])]
              print('true' if 'copilot-swe-agent' in assignees or 'Copilot' in assignees else 'false')
          except Exception:
              print('false')
          PY
            ) || true

            if [[ "${current_assignees}" == "true" ]]; then
              echo "  copilot-swe-agent は既にアサイン済みです。スキップします。"
              return 0
            fi

            # 冪等化ガード: 対象 Issue に紐づく Open な PR が既に存在する場合はスキップ
            local existing_prs
            existing_prs=$(curl -s \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/timeline?per_page=100" \
              | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              events = json.load(sys.stdin)
              if not isinstance(events, list):
                  print('false')
                  sys.exit(0)
          except Exception:
              print('false')
              sys.exit(0)
          for e in events:
              if e.get('event') == 'cross-referenced':
                  source = e.get('source', {}).get('issue', {})
                  pr = source.get('pull_request', {})
                  if pr and source.get('state') == 'open':
                      print('true')
                      sys.exit(0)
          print('false')
          PY
            ) || true

            if [[ "${existing_prs}" == "true" ]]; then
              echo "  Issue #${issue_num} に紐づく Open な PR が既に存在します。スキップします。"
              return 0
            fi

            if [[ -z "${COPILOT_PAT}" ]]; then
              echo "WARNING: COPILOT_PAT が設定されていません。Copilot アサインをスキップします。" >&2
              return 1
            fi

            local OWNER="${REPO%/*}"
            local REPO_NAME="${REPO#*/}"

            local max_assign_retry=3
            local assign_wait=5
            local assign_success=false

            for assign_attempt in $(seq 1 "${max_assign_retry}"); do
              echo "  アサイン試行 ${assign_attempt}/${max_assign_retry}..."

              # 1回のクエリで bot_id / issue_node_id / repo_node_id をまとめて取得
              local query_result
              query_result=$(GH_TOKEN="${COPILOT_PAT}" gh api graphql \
                -f query="
          query(\$issueNumber: Int!) {
            repository(owner: \"${OWNER}\", name: \"${REPO_NAME}\") {
              id
              issue(number: \$issueNumber) { id }
              suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                nodes {
                  login
                  ... on Bot { id databaseId }
                }
              }
            }
          }
                " \
                -F issueNumber="${issue_num}" \
                2>&1) || true

              echo "  GraphQL クエリ結果: ${query_result}"

              if [[ -z "${query_result}" ]]; then
                echo "WARNING: GraphQL クエリの実行に失敗しました。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi

              local bot_id issue_node_id repo_node_id
              IFS=$'\t' read -r bot_id issue_node_id repo_node_id < <(echo "${query_result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          d = json.load(sys.stdin)
          repo = d.get('data', {}).get('repository', {})
          bot = ''
          for a in repo.get('suggestedActors', {}).get('nodes', []):
              if a.get('login') == 'copilot-swe-agent':
                  bot = a.get('id', '')
                  break
          issue = repo.get('issue', {}).get('id', '')
          print(bot + '\t' + issue + '\t' + repo.get('id', ''))
          PY
              ) || true

              if [[ -z "${bot_id}" ]]; then
                echo "WARNING: copilot-swe-agent の Bot ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              if [[ -z "${issue_node_id}" ]]; then
                echo "WARNING: Issue #${issue_num} の Node ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              if [[ -z "${repo_node_id}" ]]; then
                echo "WARNING: Repository の Node ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              echo "  Bot ID: ${bot_id}, Issue Node ID: ${issue_node_id}, Repo Node ID: ${repo_node_id}"

              # addAssigneesToAssignable mutation（全変数を -f/-f フラグで渡す・インジェクション防止）
              local result
              result=$(GH_TOKEN="${COPILOT_PAT}" gh api graphql \
                -H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection' \
                -f query="
          mutation(\$assignableId: ID!, \$botId: ID!, \$targetRepositoryId: ID!, \$baseRef: String!, \$customInstructions: String!, \$customAgent: String!) {
            addAssigneesToAssignable(input: {
              assignableId: \$assignableId,
              assigneeIds: [\$botId],
              agentAssignment: {
                targetRepositoryId: \$targetRepositoryId,
                baseRef: \$baseRef,
                customInstructions: \$customInstructions,
                customAgent: \$customAgent,
                model: \"\"
              }
            }) {
              assignable {
                ... on Issue {
                  id
                  title
                  assignees(first: 10) {
                    nodes { login }
                  }
                }
              }
            }
          }
                " \
                -f assignableId="${issue_node_id}" \
                -f botId="${bot_id}" \
                -f targetRepositoryId="${repo_node_id}" \
                -f baseRef="${base_branch}" \
                -f customInstructions="${custom_instructions}" \
                -f customAgent="${custom_agent}" \
                2>&1) || true

              echo "  GraphQL mutation レスポンス: ${result}"

              # mutation レスポンスのエラーチェック
              local has_errors
              has_errors=$(echo "${result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              print('true' if d.get('errors') else 'false')
          except Exception:
              print('true')
          PY
              ) || true

              if [[ "${has_errors}" == "true" ]]; then
                echo "WARNING: GraphQL mutation にエラーが含まれています。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi

              # copilot-swe-agent が assignees に含まれるか検証
              local is_assigned
              is_assigned=$(echo "${result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              nodes = d.get('data', {}).get('addAssigneesToAssignable', {}).get('assignable', {}).get('assignees', {}).get('nodes', [])
              print('true' if any(a.get('login') in ('copilot-swe-agent', 'Copilot') for a in nodes) else 'false')
          except Exception:
              print('false')
          PY
              ) || true

              if [[ "${is_assigned}" == "true" ]]; then
                echo "  copilot-swe-agent のアサインを確認しました。"
                assign_success=true
                break
              fi

              echo "WARNING: copilot-swe-agent が assignees に含まれていません。試行 ${assign_attempt}/${max_assign_retry}" >&2
              sleep "${assign_wait}"
              assign_wait=$((assign_wait * 2))
            done

            if [[ "${assign_success}" != "true" ]]; then
              local fail_msg
              fail_msg=$(printf '⚠️ Copilot coding agent (copilot-swe-agent) を Issue #%s にアサインできませんでした。\n\n手動でアサインする手順:\n1. Issue #%s を開く\n2. 右サイドバーの「Assignees」から `copilot-swe-agent` を選択する\n\n失敗原因として考えられるもの:\n- `COPILOT_PAT` の権限不足または失効\n- Copilot coding agent が有効化されていない\n- GraphQL API の一時的な障害' "${issue_num}" "${issue_num}")
              post_comment "${issue_num}" "${fail_msg}" || true
              echo "WARNING: Issue #${issue_num} へのアサイン失敗通知を投稿しました。" >&2
              return 1
            fi

            echo "=== Copilot アサイン完了: Issue #${issue_num} ==="
            sleep 2
          }

          # コメント投稿
          post_comment() {
            local issue_num="$1"
            local comment_body="$2"
            local data
            data=$(python3 -c "import sys,json; print(json.dumps({'body': sys.argv[1]}))" "${comment_body}")
            api_call POST \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/comments" \
              "${data}" > /dev/null
            sleep 1
          }

          # Issue body から Custom Agent 名を抽出
          extract_custom_agent() {
            local body="$1"
            echo "${body}" | python3 /dev/fd/3 3<<'PY'
          import sys, re
          body = sys.stdin.read()
          m = re.search(r'## Custom Agent\s*\n\s*`([^`]+)`', body)
          print(m.group(1) if m else '')
          PY
          }

          # ---- Issue body パース ----
          PARSED=$(python3 - <<'PYEOF'
          import sys, os, re, json

          body = os.environ.get("ISSUE_BODY", "")

          # ブランチ名抽出（input フォームの値）
          branch = "main"
          m = re.search(r"###\s*対象ブランチ\s*\n+(.+)", body)
          if m:
              branch = m.group(1).strip()
              if not branch or branch == "_No response_":
                  branch = "main"

          # リソースグループ名抽出
          resource_group = ""
          m = re.search(r"###\s*リソースグループ名\s*\n+(.+)", body)
          if m:
              resource_group = m.group(1).strip()
              if resource_group == "_No response_":
                  resource_group = ""

          # 実行するステップからスキップ対象を検出
          skip_steps = set()
          exec_section = re.search(
              r"###\s*実行するステップ\s*\n(.*?)(?=###|\Z)",
              body, re.DOTALL
          )
          if exec_section:
              section_text = exec_section.group(1)
              all_items = re.findall(
                  r"-\s*\[[ xX]\]\s*Step\.(\d+)",
                  section_text
              )
              all_steps = set(all_items)
              checked_items = re.findall(
                  r"-\s*\[[xX]\]\s*Step\.(\d+)",
                  section_text
              )
              exec_steps = set(checked_items)
              skip_steps = all_steps - exec_steps
              # チェックが1つもない場合は「全ステップ実行」とみなしてスキップなし
              if not exec_steps and all_steps:
                  skip_steps = set()

          # 追加コメント抽出
          additional_comment = ""
          m = re.search(r"###\s*追加コメント\s*\n+(.*?)(?=###|\Z)", body, re.DOTALL)
          if m:
              additional_comment = m.group(1).strip()
              if additional_comment == "_No response_":
                  additional_comment = ""

          # ユースケースID抽出
          usecase_id = ""
          m = re.search(r"###\s*ユースケースID\s*\n+(.+)", body)
          if m:
              usecase_id = m.group(1).strip()
              if usecase_id == "_No response_":
                  usecase_id = ""

          result = {"branch": branch, "resource_group": resource_group, "skip_steps": list(skip_steps), "additional_comment": additional_comment, "usecase_id": usecase_id}
          print(json.dumps(result))
          PYEOF
          )

          BRANCH=$(echo "${PARSED}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['branch'])")
          RESOURCE_GROUP=$(echo "${PARSED}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['resource_group'])")
          SKIP_STEPS=$(echo "${PARSED}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(' '.join(d['skip_steps']))")
          ADDITIONAL_COMMENT=$(echo "${PARSED}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['additional_comment'])")
          USECASE_ID=$(echo "${PARSED}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('usecase_id',''))")

          echo "対象ブランチ: ${BRANCH}"
          echo "リソースグループ名: ${RESOURCE_GROUP}"
          echo "スキップ Steps: ${SKIP_STEPS}"
          echo "ユースケースID: ${USECASE_ID}"

          # ---- ROOT_REF（リソースグループメタコメント含む）----
          ROOT_REF=$(printf '<!-- root-issue: #%s -->\n<!-- branch: %s -->\n<!-- resource-group: %s -->' \
            "${ROOT_ISSUE}" "${BRANCH}" "${RESOURCE_GROUP}")

          # 追加コメントが存在する場合のフッター
          if [[ -n "${ADDITIONAL_COMMENT}" ]]; then
            ADDITIONAL_SECTION=$(printf '\n\n## 追加コメント\n%s' "${ADDITIONAL_COMMENT}")
          else
            ADDITIONAL_SECTION=""
          fi

          # ---- Root Issue body からスキップ対象のステップ行を除去して更新 ----
          # （注意: ISSUE_BODY シェル変数は古い値のまま。パースは完了済みなので影響なし）
          if [[ -n "${SKIP_STEPS}" ]]; then
            echo "Root Issue body から未チェックのステップを除去します..."

            PATCH_JSON_FILE=$(mktemp)

            python3 - "${SKIP_STEPS}" "${PATCH_JSON_FILE}" <<'PYBODY'
          import sys, os, re, json

          body = os.environ.get("ISSUE_BODY", "")
          skip_steps_str = sys.argv[1]
          output_file = sys.argv[2]

          skip_steps = set(skip_steps_str.split()) if skip_steps_str.strip() else set()

          if skip_steps:
              lines = body.split('\n')
              new_lines = []
              for line in lines:
                  # 未チェック行のみ除去（チェック済み行 - [x] は残す）
                  m = re.match(r'^\s*-\s*\[[ ]\]\s*Step\.(\d+)\b', line)
                  if m and m.group(1) in skip_steps:
                      continue
                  new_lines.append(line)

              # 連続空行を最大2行に制限
              cleaned = []
              blank_count = 0
              for line in new_lines:
                  if line.strip() == '':
                      blank_count += 1
                      if blank_count <= 2:
                          cleaned.append(line)
                  else:
                      blank_count = 0
                      cleaned.append(line)

              body = '\n'.join(cleaned)

          with open(output_file, 'w', encoding='utf-8') as f:
              json.dump({'body': body}, f, ensure_ascii=False)
          PYBODY

            api_call PATCH \
              "https://api.github.com/repos/${REPO}/issues/${ROOT_ISSUE}" \
              "$(cat "${PATCH_JSON_FILE}")" > /dev/null \
              && echo "Root Issue #${ROOT_ISSUE} の body を更新しました（未チェックのステップ行を除去）。" \
              || echo "WARNING: Root Issue body の更新に失敗しました。処理を続行します。" >&2

            rm -f "${PATCH_JSON_FILE}"
          else
            echo "全ステップ実行のため Root Issue body の更新は不要です。"
          fi

          # ---- Root Issue に asd:initialized を付与 ----
          add_label "${ROOT_ISSUE}" "asd:initialized"
          echo "asd:initialized を付与しました。"

          # skip_step helper: SKIP_STEPS に Step 番号が含まれていれば true
          skip_step() { echo " ${SKIP_STEPS} " | grep -q " $1 "; }

          # ---- Step Issue 生成 ----
          S1_NUM=""  S1_ID=""
          S11_NUM="" S11_ID=""
          S12_NUM="" S12_ID=""
          S2_NUM=""  S2_ID=""
          S21_NUM="" S21_ID=""
          S22_NUM="" S22_ID=""
          S23_NUM="" S23_ID=""
          S24_NUM="" S24_ID=""
          S25_NUM="" S25_ID=""
          S26_NUM="" S26_ID=""
          S3_NUM=""  S3_ID=""
          S31_NUM="" S31_ID=""
          S32_NUM="" S32_ID=""
          S4_NUM=""  S4_ID=""
          S41_NUM="" S41_ID=""
          S42_NUM="" S42_ID=""

          # ---- Step.1 コンテナ + サブステップ ----
          if ! skip_step "1"; then
            BODY_S1=$(printf '%s\n## Step.1 コンテナ\nStep.1 はコンテナ Issue。Sub Task（Step.1.1, Step.1.2）の完了を待つ。%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.1: データ（コンテナ）" \
              "${BODY_S1}" \
              '["auto-software-dev-webapp"]')
            S1_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S1_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.1 作成: #${S1_NUM}"
            sleep 3

            # ---- Step.1.1 ----
            BODY_S11=$(printf '%s\n## 目的\nPolyglot Persistenceに基づき、全エンティティの最適Azureデータストア選定と根拠/整合性方針を文書化する。\n\n## 入力\n- `docs/data-model.md`\n- `docs/service-list.md`\n- `docs/domain-analytics.md`\n- （任意）`docs/templates/agent-playbook.md`\n\n## 出力\n- `docs/azure/AzureServices-data.md`\n\n## Custom Agent\n`Dev-WebAzure-DataDesign` を使用\n\n## 完了条件\n- `docs/azure/AzureServices-data.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.1.1: Azure データストア選定" \
              "${BODY_S11}" \
              '["auto-software-dev-webapp"]')
            S11_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S11_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.1.1 作成: #${S11_NUM}"
            sleep 3

            # ---- Step.1.2 ----
            BODY_S12=$(printf '%s\n## 目的\nAzure CLIでデータ系サービスを最小構成で作成し、サンプルデータを変換・一括登録する（冪等・検証付き）。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/azure/AzureServices-data.md`\n- `docs/service-catalog.md`\n- `data/sample-data.json`\n\n## 出力\n- `infra/azure/create-azure-data-resources-prep.sh`\n- `infra/azure/create-azure-data-resources.sh`\n- `data/azure/data-registration-script.sh`\n- `docs/azure/service-catalog.md` 更新\n\n## Custom Agent\n`Dev-WebAzure-DataDeploy` を使用\n\n## 依存\n- Step.1.1（Azure データストア選定）が `asd:done` であること\n\n## 完了条件\n- 出力ファイルが作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.1.2: Azure データサービス Deploy" \
              "${BODY_S12}" \
              '["auto-software-dev-webapp"]')
            S12_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S12_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.1.2 作成: #${S12_NUM}"
            sleep 3
          else
            echo "Step.1 はスキップされました。"
          fi

          # ---- Step.2 コンテナ + サブステップ ----
          if ! skip_step "2"; then
            BODY_S2=$(printf '%s\n## Step.2 コンテナ\nStep.2 はコンテナ Issue。Sub Task（Step.2.1〜2.6）の完了を待つ。%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2: マイクロサービス作成（コンテナ）" \
              "${BODY_S2}" \
              '["auto-software-dev-webapp"]')
            S2_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S2_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2 作成: #${S2_NUM}"
            sleep 3

            # ---- Step.2.1 ----
            BODY_S21=$(printf '%s\n## 目的\nユースケース内の全マイクロサービスについて、最適な Azure コンピュート（ホスティング）を選定し、根拠・代替案・前提・未決事項を設計書に記録する。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/service-list.md`\n- `docs/usecase-list.md`\n- `docs/data-model.md`\n- `docs/service-catalog.md`\n\n## 出力\n- `docs/azure/AzureServices-services.md`\n\n## Custom Agent\n`Dev-WebAzure-ComputeDesign` を使用\n\n## 依存\n- Step.1（データコンテナ）が `asd:done` であること\n\n## 完了条件\n- `docs/azure/AzureServices-services.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.1: Azure コンピュート選定" \
              "${BODY_S21}" \
              '["auto-software-dev-webapp"]')
            S21_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S21_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.1 作成: #${S21_NUM}"
            sleep 3

            # ---- Step.2.2 ----
            BODY_S22=$(printf '%s\n## 目的\nサービス定義書の「外部依存・統合」から、追加で必要な Azure サービス（AI/認証/統合/運用等）を選定し、根拠（Microsoft Learn）付きで記録する。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/usecase-list.md`\n- `docs/service-list.md`\n- `docs/services/{サービスID}-{サービス名}-description.md`\n- 既存採用済み（追加提案から除外）:\n  - `docs/azure/AzureServices-services.md`\n  - `docs/azure/AzureServices-data.md`\n\n## 出力\n- `docs/azure/AzureServices-services-additional.md`\n\n## Custom Agent\n`Dev-WebAzure-AddServiceDesign` を使用\n\n## 依存\n- Step.2.1（Azure コンピュート選定）が `asd:done` であること\n\n## 完了条件\n- `docs/azure/AzureServices-services-additional.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.2: 追加 Azure サービス選定" \
              "${BODY_S22}" \
              '["auto-software-dev-webapp"]')
            S22_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S22_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.2 作成: #${S22_NUM}"
            sleep 3

            # ---- Step.2.3 ----
            BODY_S23=$(printf '%s\n## 目的\n`docs/azure/AzureServices-services-additional.md` を根拠に、追加Azureサービスを Azure CLI で冪等に作成する。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/azure/AzureServices-services-additional.md`\n- （任意）subscription / tenant / 優先リージョン / 命名規則\n\n## 出力\n- `infra/azure/create-azure-additional-resources-prep.sh`\n- `infra/azure/create-azure-additional-resources/create.sh`\n- （複数サービスの場合）`infra/azure/create-azure-additional-resources/services/<service>.sh`\n- `docs/service-catalog.md` 更新\n\n## Custom Agent\n`Dev-WebAzure-AddServiceDeploy` を使用\n\n## 依存\n- Step.2.2（追加 Azure サービス選定）が `asd:done` であること\n\n## 完了条件\n- 出力ファイルが作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.3: 追加 Azure サービス Deploy" \
              "${BODY_S23}" \
              '["auto-software-dev-webapp"]')
            S23_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S23_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.3 作成: #${S23_NUM}"
            sleep 3

            # ---- Step.2.4 ----
            BODY_S24=$(printf '%s\n## 目的\nマイクロサービス定義書から全てのサービスの Azure Functions を実装し、テスト/最小ドキュメント/設定雛形まで揃える。\n\n## 入力\n- `docs/services/{serviceId}-{serviceNameSlug}-description.md`\n- Azure Functions プログラミング言語: `C#（最新版のAzure Functionsでサポートされているもの）`\n- `docs/service-list.md`\n- `docs/data-model.md`\n- `docs/service-catalog.md`\n- `docs/azure/AzureServices-*.md`\n\n## 出力\n- `api/{サービスID}-{サービス名}/` 配下に Azure Functions を作成/更新\n- `test/api/` に単体テスト（外部I/Oはモック）\n- （任意推奨）`test/api/smoke-ui/index.html`\n\n## Custom Agent\n`Dev-WebAzure-ServiceCoding-AzureFunctions` を使用\n\n## 依存\n- Step.2.3（追加 Azure サービス Deploy）が `asd:done` であること\n\n## 完了条件\n- `api/` 配下に Azure Functions が実装されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.4: サービスコード実装 (Azure Functions)" \
              "${BODY_S24}" \
              '["auto-software-dev-webapp"]')
            S24_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S24_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.4 作成: #${S24_NUM}"
            sleep 3

            # ---- Step.2.5 ----
            BODY_S25=$(printf '%s\n## 目的\nサービスリストの全てのサービスを、Azure Functions用に作成/更新→デプロイ、GitHub Actions で CI/CD 構築、API スモークテスト（+手動UI）追加まで行う。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/service-list.md`\n- `docs/service-catalog.md`\n- `api/{サービスID}-{サービス名}/`\n- リージョン: `Japan East`（優先。利用不可なら `Japan West`、それも不可なら `Southeast Asia`）\n\n## 出力\n- `infra/azure/create-azure-api-resources-prep.sh`\n- `/.github/workflows/` にCI/CD（OIDC + azure/login 優先）\n- `docs/service-catalog.md` 更新\n- `test/{サービスID}-{サービス名}/` にスモークテスト + 手動UI\n\n## 注意\nCopilot が push しても workflow は自動実行されないことがある。PR 側でユーザーが実行承認できるよう説明を残す。\n\n## Custom Agent\n`Dev-WebAzure-ComputeDeploy-AzureFunctions` を使用\n\n## 依存\n- Step.2.4（サービスコード実装）が `asd:done` であること\n\n## 完了条件\n- デプロイスクリプトと CI/CD ワークフローが作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.5: Azure Compute Deploy" \
              "${BODY_S25}" \
              '["auto-software-dev-webapp"]')
            S25_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S25_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.5 作成: #${S25_NUM}"
            sleep 3

            # ---- Step.2.6 ----
            USECASE_PATH=""
            if [[ -n "${USECASE_ID}" ]]; then
              USECASE_PATH="docs/usecase/${USECASE_ID}/usecase-description.md"
            fi

            BODY_S26=$(printf '%s\n## 目的\nユースケース記述を入力として、AI Agent のアプリケーション定義・粒度設計・詳細設計を実施し、Agent 一覧を出力する。\n\n## 入力\n- ユースケースID: %s\n- ユースケース記述: %s\n- ガイドライン: `ApplicationDesign-AIAgent.md`\n- 参照（存在すれば）:\n  - `docs/service-catalog.md`\n  - `docs/service-list.md`\n  - `docs/data-model.md`\n  - `docs/domain-analytics.md`\n  - `docs/usecase-list.md`\n  - `docs/services/SVC-*.md`\n  - `docs/azure/AzureServices-data.md`\n  - `docs/azure/AzureServices-services-additional.md`\n\n## 成果物\n- `docs/usecase/%s/agent/agent-application-definition.md`\n- `docs/usecase/%s/agent/agent-architecture.md`\n- `docs/usecase/%s/agent/agent-detail-<Agent-ID>-<Agent名>.md`（Agent ごと）\n- `docs/AI-Agents-list.md`\n\n## Custom Agent\n`Arch-AIAgentDesign`\n\n## 依存\n- Step.2.5（Azure Compute Deploy）が `asd:done` であること\n\n## 完了条件\n- `docs/AI-Agents-list.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${USECASE_ID}" "${USECASE_PATH}" "${USECASE_ID}" "${USECASE_ID}" "${USECASE_ID}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.2.6: AI Agent 構成" \
              "${BODY_S26}" \
              '["auto-software-dev-webapp"]')
            S26_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S26_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.2.6 作成: #${S26_NUM}"
            sleep 3
          else
            echo "Step.2 はスキップされました。"
          fi

          # ---- Step.3 コンテナ + サブステップ ----
          if ! skip_step "3"; then
            BODY_S3=$(printf '%s\n## Step.3 コンテナ\nStep.3 はコンテナ Issue。Sub Task（Step.3.1, Step.3.2）の完了を待つ。%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.3: UI 作成（コンテナ）" \
              "${BODY_S3}" \
              '["auto-software-dev-webapp"]')
            S3_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S3_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.3 作成: #${S3_NUM}"
            sleep 3

            # ---- Step.3.1 ----
            BODY_S31=$(printf '%s\n## 目的\n画面定義書に基づき、全ての画面のUIを実装し、サービスカタログに基づくAPIクライアント層を整備する。\n\n## 入力\n- `docs/screen/{画面ID}-description.md`\n- `docs/screen-list.md`\n- `docs/service-catalog.md`\n- UI実装技術: `HTML5/CSS/JavaScript（リポジトリ既存規約に合わせる）`\n- `docs/usecase-list.md`\n- `data/sample-data.json`\n\n## 出力\n- `app/` 配下にUI実装\n\n## Custom Agent\n`Dev-WebAzure-UICoding` を使用\n\n## 依存\n- Step.2（マイクロサービス作成コンテナ）が `asd:done` であること\n\n## 完了条件\n- `app/` 配下にUI実装が完成している\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.3.1: UI 実装" \
              "${BODY_S31}" \
              '["auto-software-dev-webapp"]')
            S31_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S31_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.3.1 作成: #${S31_NUM}"
            sleep 3

            # ---- Step.3.2 ----
            BODY_S32=$(printf '%s\n## 目的\nAzure Static Web Apps へのWebデプロイと、GitHub Actionsによる継続的デリバリー（CD）構築を実施する。\n\n## 入力\n- リソースグループ名: `%s`\n- デプロイブランチ: `main`\n- `app_location`: `app/`\n- `api_location`: `app/lib/api/`\n- リージョン優先: East Asia → Japan West → Southeast Asia\n\n## 出力\n- `infra/azure/create-azure-webui-resources-prep.sh`\n- `infra/azure/create-azure-webui-resources.sh`\n- `.github/workflows/` に SWA デプロイワークフロー（Secret `AZURE_STATIC_WEB_APPS_API_TOKEN` 参照）\n- `docs/service-catalog.md` 更新\n\n## Custom Agent\n`Dev-WebAzure-UIDeploy-AzureStaticWebApps` を使用\n\n## 依存\n- Step.3.1（UI 実装）が `asd:done` であること\n\n## 完了条件\n- デプロイスクリプトと SWA ワークフローが作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.3.2: Web アプリ Deploy (Azure Static Web Apps)" \
              "${BODY_S32}" \
              '["auto-software-dev-webapp"]')
            S32_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S32_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.3.2 作成: #${S32_NUM}"
            sleep 3
          else
            echo "Step.3 はスキップされました。"
          fi

          # ---- Step.4 コンテナ + サブステップ ----
          if ! skip_step "4"; then
            BODY_S4=$(printf '%s\n## Step.4 コンテナ\nStep.4 はコンテナ Issue。Sub Task（Step.4.1, Step.4.2）の**並列**完了を待つ。%s' \
              "${ROOT_REF}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.4: アーキテクチャレビュー（コンテナ）" \
              "${BODY_S4}" \
              '["auto-software-dev-webapp"]')
            S4_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S4_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.4 作成: #${S4_NUM}"
            sleep 3

            # ---- Step.4.1 ----
            BODY_S41=$(printf '%s\n## 目的\nデプロイ済みAzureリソースを棚卸しし、Azure Well-Architected Framework（5本柱）と Azure Security Benchmark v3 を根拠にアーキテクチャ/セキュリティをレビューして、日本語のMermaid図付きレポートを生成する。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/usecase-detail.md`\n- `docs/service-catalog.md`\n- `docs/azure/AzureServices-services.md`\n- `docs/azure/AzureServices-data.md`\n- `docs/azure/AzureServices-services-additional.md`\n\n## 出力\n- `docs/azure/Azure-ArchitectureReview-Report.md`\n\n## Custom Agent\n`QA-AzureArchitectureReview` を使用\n\n## 依存\n- Step.3（UI 作成コンテナ）が `asd:done` であること\n- Step.4.2 と並列実行可能\n\n## 完了条件\n- `docs/azure/Azure-ArchitectureReview-Report.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.4.1: WAF アーキテクチャレビュー" \
              "${BODY_S41}" \
              '["auto-software-dev-webapp"]')
            S41_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S41_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.4.1 作成: #${S41_NUM}"
            sleep 3

            # ---- Step.4.2 ----
            BODY_S42=$(printf '%s\n## 目的\nサービスカタログ準拠で Azure 依存（参照・設定・IaC）を証跡付きで点検し、必要なら最小差分で修正する。\n\n## 入力\n- リソースグループ名: `%s`\n- `docs/service-catalog.md`\n- `docs/azure/AzureServices-services*.md`\n- `docs/azure/AzureServices-data*.md`\n- `app/`, `api/`, `infra/`, `config/`, `.github/workflows/`\n\n## 出力\n- `docs/azure/DependencyReview-Report.md`\n\n## Custom Agent\n`QA-AzureDependencyReview` を使用\n\n## 依存\n- Step.3（UI 作成コンテナ）が `asd:done` であること\n- Step.4.1 と並列実行可能\n\n## 完了条件\n- `docs/azure/DependencyReview-Report.md` が作成されている\n- 完了時に自身に `asd:done` ラベルを付与すること%s' \
              "${ROOT_REF}" "${RESOURCE_GROUP}" "${ADDITIONAL_SECTION}")
            RESP=$(create_issue \
              "[ASDW] Step.4.2: 整合性チェック" \
              "${BODY_S42}" \
              '["auto-software-dev-webapp"]')
            S42_NUM=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['number'])")
            S42_ID=$(echo "${RESP}" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['id'])")
            echo "Step.4.2 作成: #${S42_NUM}"
            sleep 3
          else
            echo "Step.4 はスキップされました。"
          fi

          # ---- Sub Issue 紐付け ----
          echo "Sub Issue 紐付けを開始します..."

          # Root → Step.1, Step.2, Step.3, Step.4（コンテナ）
          [[ -n "${S1_ID}" ]] && { link_sub_issue "${ROOT_ISSUE}" "${S1_ID}"; echo "Root → Step.1 紐付け完了"; }
          [[ -n "${S2_ID}" ]] && { link_sub_issue "${ROOT_ISSUE}" "${S2_ID}"; echo "Root → Step.2 紐付け完了"; }
          [[ -n "${S3_ID}" ]] && { link_sub_issue "${ROOT_ISSUE}" "${S3_ID}"; echo "Root → Step.3 紐付け完了"; }
          [[ -n "${S4_ID}" ]] && { link_sub_issue "${ROOT_ISSUE}" "${S4_ID}"; echo "Root → Step.4 紐付け完了"; }

          # Step.1 → Step.1.1, Step.1.2
          [[ -n "${S1_NUM}" && -n "${S11_ID}" ]] && { link_sub_issue "${S1_NUM}" "${S11_ID}"; echo "Step.1 → Step.1.1 紐付け完了"; }
          [[ -n "${S1_NUM}" && -n "${S12_ID}" ]] && { link_sub_issue "${S1_NUM}" "${S12_ID}"; echo "Step.1 → Step.1.2 紐付け完了"; }

          # Step.2 → Step.2.1〜2.6
          [[ -n "${S2_NUM}" && -n "${S21_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S21_ID}"; echo "Step.2 → Step.2.1 紐付け完了"; }
          [[ -n "${S2_NUM}" && -n "${S22_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S22_ID}"; echo "Step.2 → Step.2.2 紐付け完了"; }
          [[ -n "${S2_NUM}" && -n "${S23_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S23_ID}"; echo "Step.2 → Step.2.3 紐付け完了"; }
          [[ -n "${S2_NUM}" && -n "${S24_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S24_ID}"; echo "Step.2 → Step.2.4 紐付け完了"; }
          [[ -n "${S2_NUM}" && -n "${S25_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S25_ID}"; echo "Step.2 → Step.2.5 紐付け完了"; }
          [[ -n "${S2_NUM}" && -n "${S26_ID}" ]] && { link_sub_issue "${S2_NUM}" "${S26_ID}"; echo "Step.2 → Step.2.6 紐付け完了"; }

          # Step.3 → Step.3.1, Step.3.2
          [[ -n "${S3_NUM}" && -n "${S31_ID}" ]] && { link_sub_issue "${S3_NUM}" "${S31_ID}"; echo "Step.3 → Step.3.1 紐付け完了"; }
          [[ -n "${S3_NUM}" && -n "${S32_ID}" ]] && { link_sub_issue "${S3_NUM}" "${S32_ID}"; echo "Step.3 → Step.3.2 紐付け完了"; }

          # Step.4 → Step.4.1, Step.4.2
          [[ -n "${S4_NUM}" && -n "${S41_ID}" ]] && { link_sub_issue "${S4_NUM}" "${S41_ID}"; echo "Step.4 → Step.4.1 紐付け完了"; }
          [[ -n "${S4_NUM}" && -n "${S42_ID}" ]] && { link_sub_issue "${S4_NUM}" "${S42_ID}"; echo "Step.4 → Step.4.2 紐付け完了"; }

          # ---- 最初の leaf Step を起動（Step.1.1 → Step.2.1 → Step.3.1 → Step.4.1/4.2 の順でフォールバック）----
          if [[ -n "${S11_NUM}" ]]; then
            add_label "${S11_NUM}" "asd:ready"
            CA=$(extract_custom_agent "${BODY_S11}")
            if assign_copilot "${S11_NUM}" "${CA}" "${BRANCH}" ""; then
              add_label "${S11_NUM}" "asd:running"
              echo "Step.1.1 に copilot アサイン + asd:running 付与完了"
            else
              echo "WARNING: Step.1.1 へのアサイン失敗。asd:running は付与しません。"
            fi
          elif [[ -n "${S21_NUM}" ]]; then
            add_label "${S21_NUM}" "asd:ready"
            CA=$(extract_custom_agent "${BODY_S21}")
            if assign_copilot "${S21_NUM}" "${CA}" "${BRANCH}" ""; then
              add_label "${S21_NUM}" "asd:running"
              echo "Step.1 がスキップ済み: Step.2.1 (#${S21_NUM}) を起動しました。"
            else
              echo "WARNING: Step.2.1 へのアサイン失敗。asd:running は付与しません。"
            fi
          elif [[ -n "${S31_NUM}" ]]; then
            add_label "${S31_NUM}" "asd:ready"
            CA=$(extract_custom_agent "${BODY_S31}")
            if assign_copilot "${S31_NUM}" "${CA}" "${BRANCH}" ""; then
              add_label "${S31_NUM}" "asd:running"
              echo "Step.1/2 がスキップ済み: Step.3.1 (#${S31_NUM}) を起動しました。"
            else
              echo "WARNING: Step.3.1 へのアサイン失敗。asd:running は付与しません。"
            fi
          elif [[ -n "${S41_NUM}" ]] || [[ -n "${S42_NUM}" ]]; then
            if [[ -n "${S41_NUM}" ]]; then
              add_label "${S41_NUM}" "asd:ready"
              CA=$(extract_custom_agent "${BODY_S41}")
              if assign_copilot "${S41_NUM}" "${CA}" "${BRANCH}" ""; then
                add_label "${S41_NUM}" "asd:running"
                echo "Step.1/2/3 がスキップ済み: Step.4.1 (#${S41_NUM}) を起動しました。"
              else
                echo "WARNING: Step.4.1 へのアサイン失敗。asd:running は付与しません。"
              fi
            fi
            if [[ -n "${S42_NUM}" ]]; then
              add_label "${S42_NUM}" "asd:ready"
              CA=$(extract_custom_agent "${BODY_S42}")
              if assign_copilot "${S42_NUM}" "${CA}" "${BRANCH}" ""; then
                add_label "${S42_NUM}" "asd:running"
                echo "Step.1/2/3 がスキップ済み: Step.4.2 (#${S42_NUM}) を起動しました。"
              else
                echo "WARNING: Step.4.2 へのアサイン失敗。asd:running は付与しません。"
              fi
            fi
          else
            echo "起動可能な leaf Step が存在しません。初期化をスキップします。"
          fi

          echo "初期化完了。"

      # ----------------------------------------------------------------
      # 4. 状態遷移: asd:done ラベル付与時
      # ----------------------------------------------------------------
      - name: 状態遷移処理
        if: steps.gate.outputs.mode == 'state_transition'
        env:
          DONE_ISSUE_NUMBER: ${{ steps.gate.outputs.issue_number }}
        run: |
          set -euo pipefail

          # Issue の body と title を API 経由で安全に取得（YAML 展開問題を回避）
          _ISSUE_JSON=$(curl -sf \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${REPO}/issues/${DONE_ISSUE_NUMBER}")
          DONE_ISSUE_BODY=$(echo "${_ISSUE_JSON}" | python3 -c "import sys,json; print(json.load(sys.stdin).get('body',''))")
          DONE_ISSUE_TITLE=$(echo "${_ISSUE_JSON}" | python3 -c "import sys,json; print(json.load(sys.stdin).get('title',''))")
          export DONE_ISSUE_BODY DONE_ISSUE_TITLE

          # closed イベント由来の場合: asd:done ラベルをまだ持っていなければ付与する
          # （labeled(asd:done) イベントと closed イベントのどちらで state_transition に来ても正しく動作するための冪等処理）
          _HAS_DONE_LABEL=$(echo "${_ISSUE_JSON}" | python3 -c "
          import sys, json
          d = json.load(sys.stdin)
          labels = [l['name'] for l in d.get('labels', [])]
          print('true' if 'asd:done' in labels else 'false')
          ")
          if [[ "${_HAS_DONE_LABEL}" == "false" ]]; then
            echo "asd:done ラベルを付与します（closed イベント由来）..."
            # add_label関数の定義より前なので直接curl（リトライなし・エラーは無視）
            curl -s -o /dev/null \
              -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${DONE_ISSUE_NUMBER}/labels" \
              -d '{"labels":["asd:done"]}' || true
            echo "asd:done ラベルを付与しました。"
            sleep 2
          fi

          if [[ -z "${COPILOT_PAT}" ]]; then
            echo "WARNING: COPILOT_PAT が設定されていません。Copilot アサインは全てスキップされます。" >&2
          fi

          # ---- ユーティリティ関数（再定義） ----
          api_call() {
            local method="$1"; shift
            local url="$1"; shift
            local data="${1:-}"
            local max_retry=5
            local wait=1
            local http_code response body

            for i in $(seq 1 "${max_retry}"); do
              if [[ -n "${data}" ]]; then
                response=$(curl -s -w "\n%{http_code}" \
                  -X "${method}" \
                  -H "Authorization: Bearer ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  -H "Content-Type: application/json" \
                  "${url}" \
                  -d "${data}")
              else
                response=$(curl -s -w "\n%{http_code}" \
                  -X "${method}" \
                  -H "Authorization: Bearer ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "${url}")
              fi
              http_code=$(echo "${response}" | tail -1)
              body=$(echo "${response}" | head -n -1)
              if [[ "${http_code}" =~ ^2 ]]; then
                echo "${body}"
                return 0
              fi
              echo "API エラー: HTTP ${http_code}、${wait}秒後にリトライ (${i}/${max_retry})" >&2
              sleep "${wait}"
              wait=$((wait * 2))
            done
            echo "API 呼び出し失敗: ${method} ${url}" >&2
            return 1
          }

          add_label() {
            local issue_num="$1"
            local label="$2"
            api_call POST \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/labels" \
              "{\"labels\":[\"${label}\"]}" > /dev/null
            sleep 1
          }

          assign_copilot() {
            local issue_num="$1"
            local custom_agent="${2:-}"
            local base_branch="${3:-main}"
            local custom_instructions="${4:-}"

            echo "=== Copilot アサイン開始: Issue #${issue_num} ==="
            echo "  custom_agent: ${custom_agent}"
            echo "  base_branch: ${base_branch}"

            # 冪等化ガード: 既に copilot-swe-agent がアサインされている場合はスキップ
            local current_assignees
            current_assignees=$(curl -s \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}" \
              | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              if not isinstance(d, dict):
                  print('false')
                  sys.exit(0)
              assignees = [a.get('login', '') for a in d.get('assignees', [])]
              print('true' if 'copilot-swe-agent' in assignees or 'Copilot' in assignees else 'false')
          except Exception:
              print('false')
          PY
            ) || true

            if [[ "${current_assignees}" == "true" ]]; then
              echo "  copilot-swe-agent は既にアサイン済みです。スキップします。"
              return 0
            fi

            # 冪等化ガード: 対象 Issue に紐づく Open な PR が既に存在する場合はスキップ
            local existing_prs
            existing_prs=$(curl -s \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/timeline?per_page=100" \
              | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              events = json.load(sys.stdin)
              if not isinstance(events, list):
                  print('false')
                  sys.exit(0)
          except Exception:
              print('false')
              sys.exit(0)
          for e in events:
              if e.get('event') == 'cross-referenced':
                  source = e.get('source', {}).get('issue', {})
                  pr = source.get('pull_request', {})
                  if pr and source.get('state') == 'open':
                      print('true')
                      sys.exit(0)
          print('false')
          PY
            ) || true

            if [[ "${existing_prs}" == "true" ]]; then
              echo "  Issue #${issue_num} に紐づく Open な PR が既に存在します。スキップします。"
              return 0
            fi

            if [[ -z "${COPILOT_PAT}" ]]; then
              echo "WARNING: COPILOT_PAT が設定されていません。Copilot アサインをスキップします。" >&2
              return 1
            fi

            local OWNER="${REPO%/*}"
            local REPO_NAME="${REPO#*/}"

            local max_assign_retry=3
            local assign_wait=5
            local assign_success=false

            for assign_attempt in $(seq 1 "${max_assign_retry}"); do
              echo "  アサイン試行 ${assign_attempt}/${max_assign_retry}..."

              # 1回のクエリで bot_id / issue_node_id / repo_node_id をまとめて取得
              local query_result
              query_result=$(GH_TOKEN="${COPILOT_PAT}" gh api graphql \
                -f query="
          query(\$issueNumber: Int!) {
            repository(owner: \"${OWNER}\", name: \"${REPO_NAME}\") {
              id
              issue(number: \$issueNumber) { id }
              suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                nodes {
                  login
                  ... on Bot { id databaseId }
                }
              }
            }
          }
                " \
                -F issueNumber="${issue_num}" \
                2>&1) || true

              echo "  GraphQL クエリ結果: ${query_result}"

              if [[ -z "${query_result}" ]]; then
                echo "WARNING: GraphQL クエリの実行に失敗しました。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi

              local bot_id issue_node_id repo_node_id
              IFS=$'\t' read -r bot_id issue_node_id repo_node_id < <(echo "${query_result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          d = json.load(sys.stdin)
          repo = d.get('data', {}).get('repository', {})
          bot = ''
          for a in repo.get('suggestedActors', {}).get('nodes', []):
              if a.get('login') == 'copilot-swe-agent':
                  bot = a.get('id', '')
                  break
          issue = repo.get('issue', {}).get('id', '')
          print(bot + '\t' + issue + '\t' + repo.get('id', ''))
          PY
              ) || true

              if [[ -z "${bot_id}" ]]; then
                echo "WARNING: copilot-swe-agent の Bot ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              if [[ -z "${issue_node_id}" ]]; then
                echo "WARNING: Issue #${issue_num} の Node ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              if [[ -z "${repo_node_id}" ]]; then
                echo "WARNING: Repository の Node ID を取得できませんでした。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi
              echo "  Bot ID: ${bot_id}, Issue Node ID: ${issue_node_id}, Repo Node ID: ${repo_node_id}"

              # addAssigneesToAssignable mutation（全変数を -f/-f フラグで渡す・インジェクション防止）
              local result
              result=$(GH_TOKEN="${COPILOT_PAT}" gh api graphql \
                -H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection' \
                -f query="
          mutation(\$assignableId: ID!, \$botId: ID!, \$targetRepositoryId: ID!, \$baseRef: String!, \$customInstructions: String!, \$customAgent: String!) {
            addAssigneesToAssignable(input: {
              assignableId: \$assignableId,
              assigneeIds: [\$botId],
              agentAssignment: {
                targetRepositoryId: \$targetRepositoryId,
                baseRef: \$baseRef,
                customInstructions: \$customInstructions,
                customAgent: \$customAgent,
                model: \"\"
              }
            }) {
              assignable {
                ... on Issue {
                  id
                  title
                  assignees(first: 10) {
                    nodes { login }
                  }
                }
              }
            }
          }
                " \
                -f assignableId="${issue_node_id}" \
                -f botId="${bot_id}" \
                -f targetRepositoryId="${repo_node_id}" \
                -f baseRef="${base_branch}" \
                -f customInstructions="${custom_instructions}" \
                -f customAgent="${custom_agent}" \
                2>&1) || true

              echo "  GraphQL mutation レスポンス: ${result}"

              # mutation レスポンスのエラーチェック
              local has_errors
              has_errors=$(echo "${result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              print('true' if d.get('errors') else 'false')
          except Exception:
              print('true')
          PY
              ) || true

              if [[ "${has_errors}" == "true" ]]; then
                echo "WARNING: GraphQL mutation にエラーが含まれています。試行 ${assign_attempt}/${max_assign_retry}" >&2
                sleep "${assign_wait}"
                assign_wait=$((assign_wait * 2))
                continue
              fi

              # copilot-swe-agent が assignees に含まれるか検証
              local is_assigned
              is_assigned=$(echo "${result}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          try:
              d = json.load(sys.stdin)
              nodes = d.get('data', {}).get('addAssigneesToAssignable', {}).get('assignable', {}).get('assignees', {}).get('nodes', [])
              print('true' if any(a.get('login') in ('copilot-swe-agent', 'Copilot') for a in nodes) else 'false')
          except Exception:
              print('false')
          PY
              ) || true

              if [[ "${is_assigned}" == "true" ]]; then
                echo "  copilot-swe-agent のアサインを確認しました。"
                assign_success=true
                break
              fi

              echo "WARNING: copilot-swe-agent が assignees に含まれていません。試行 ${assign_attempt}/${max_assign_retry}" >&2
              sleep "${assign_wait}"
              assign_wait=$((assign_wait * 2))
            done

            if [[ "${assign_success}" != "true" ]]; then
              local fail_msg
              fail_msg=$(printf '⚠️ Copilot coding agent (copilot-swe-agent) を Issue #%s にアサインできませんでした。\n\n手動でアサインする手順:\n1. Issue #%s を開く\n2. 右サイドバーの「Assignees」から `copilot-swe-agent` を選択する\n\n失敗原因として考えられるもの:\n- `COPILOT_PAT` の権限不足または失効\n- Copilot coding agent が有効化されていない\n- GraphQL API の一時的な障害' "${issue_num}" "${issue_num}")
              post_comment "${issue_num}" "${fail_msg}" || true
              echo "WARNING: Issue #${issue_num} へのアサイン失敗通知を投稿しました。" >&2
              return 1
            fi

            echo "=== Copilot アサイン完了: Issue #${issue_num} ==="
            sleep 2
          }

          post_comment() {
            local issue_num="$1"
            local body="$2"
            local data
            data=$(python3 -c "import sys,json; print(json.dumps({'body': sys.argv[1]}))" "${body}")
            api_call POST \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}/comments" \
              "${data}" > /dev/null
            sleep 1
          }

          # Issue body から Custom Agent 名を抽出
          extract_custom_agent() {
            local body="$1"
            echo "${body}" | python3 /dev/fd/3 3<<'PY'
          import sys, re
          body = sys.stdin.read()
          m = re.search(r'## Custom Agent\s*\n\s*`([^`]+)`', body)
          print(m.group(1) if m else '')
          PY
          }

          activate_issue() {
            local issue_num="$1"
            local issue_body
            issue_body=$(curl -sf \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/${issue_num}" \
              | python3 -c "import sys,json; print(json.load(sys.stdin).get('body',''))") || true
            local agent_name
            agent_name=$(extract_custom_agent "${issue_body}") || true
            add_label "${issue_num}" "asd:ready"
            if assign_copilot "${issue_num}" "${agent_name}" "${BRANCH:-main}" ""; then
              add_label "${issue_num}" "asd:running"
              echo "Issue #${issue_num} を asd:ready + copilot アサイン + asd:running に設定しました。(custom_agent: ${agent_name})"
            else
              echo "WARNING: Issue #${issue_num} へのアサイン失敗。asd:running は付与しません。"
            fi
          }

          # ---- done Issue の title から Step 番号を特定 ----
          STEP_MATCH=$(echo "${DONE_ISSUE_TITLE}" | python3 /dev/fd/3 3<<'PY'
          import sys, re
          title = sys.stdin.read().strip()
          m = re.search(r'\[ASDW\] Step\.(\d+(?:\.\d+)?)', title)
          print(m.group(1) if m else '')
          PY
          )

          if [[ -z "${STEP_MATCH}" ]]; then
            echo "Step 番号が特定できません（title: ${DONE_ISSUE_TITLE}）。スキップ。"
            exit 0
          fi

          echo "完了した Step: ${STEP_MATCH}"

          # ---- Root Issue 番号の取得 ----
          ROOT_ISSUE=$(python3 - <<'PY'
          import os, re
          body = os.environ.get('DONE_ISSUE_BODY', '')
          m = re.search(r'<!-- root-issue: #(\d+) -->', body)
          print(m.group(1) if m else '')
          PY
          )

          if [[ -z "${ROOT_ISSUE}" ]]; then
            echo "Root Issue 番号が取得できません。スキップ。"
            exit 0
          fi

          echo "Root Issue: #${ROOT_ISSUE}"

          # ---- ブランチ名の取得 ----
          BRANCH=$(python3 - <<'PY'
          import os, re
          body = os.environ.get('DONE_ISSUE_BODY', '')
          m = re.search(r'<!-- branch: (.+?) -->', body)
          print(m.group(1).strip() if m else 'main')
          PY
          )

          echo "対象ブランチ: ${BRANCH}"

          # ---- Root Issue の Sub Issues を取得して Step Issue を特定 ----
          get_sub_issue_number() {
            local pattern="$1"
            # Root Issue から全 Sub Issues を取得
            local resp
            resp=$(api_call GET \
              "https://api.github.com/repos/${REPO}/issues/${ROOT_ISSUE}/sub_issues")
            echo "${resp}" | python3 /dev/fd/3 "${pattern}" 3<<'PY'
          import sys, re, json
          issues = json.load(sys.stdin)
          pattern = sys.argv[1]
          for issue in issues:
              title = issue.get('title', '')
              if re.search(pattern, title):
                  print(issue['number'])
                  break
          PY
          }

          get_sub_issue_number_from_parent() {
            local parent_num="$1"
            local pattern="$2"
            local resp
            resp=$(api_call GET \
              "https://api.github.com/repos/${REPO}/issues/${parent_num}/sub_issues")
            echo "${resp}" | python3 /dev/fd/3 "${pattern}" 3<<'PY'
          import sys, re, json
          issues = json.load(sys.stdin)
          pattern = sys.argv[1]
          for issue in issues:
              title = issue.get('title', '')
              if re.search(pattern, title):
                  print(issue['number'])
                  break
          PY
          }

          # ---- 依存関係マップに基づき次 Step を特定 & 起動 ----
          case "${STEP_MATCH}" in

            "1.1")
              # Step.1.1 完了 → Step.1.2 を起動
              S1_NUM=$(get_sub_issue_number '\[ASDW\] Step\.1:')
              if [[ -n "${S1_NUM}" ]]; then
                S12_NUM=$(get_sub_issue_number_from_parent "${S1_NUM}" '\[ASDW\] Step\.1\.2:')
                if [[ -n "${S12_NUM}" ]]; then
                  activate_issue "${S12_NUM}"
                else
                  echo "WARNING: Step.1.2 が見つかりません。"
                fi
              else
                echo "WARNING: Step.1 コンテナが見つかりません。"
              fi
              ;;

            "1.2")
              # Step.1.2 完了 → Step.1 コンテナに asd:done → Step.2.1 を起動
              S1_NUM=$(get_sub_issue_number '\[ASDW\] Step\.1:')
              if [[ -n "${S1_NUM}" ]]; then
                add_label "${S1_NUM}" "asd:done"
                echo "Step.1 コンテナに asd:done を付与しました。"
              fi
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S21_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.1:')
                if [[ -n "${S21_NUM}" ]]; then
                  activate_issue "${S21_NUM}"
                else
                  echo "WARNING: Step.2.1 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.1")
              # Step.2.1 完了 → Step.2.2 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S22_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.2:')
                if [[ -n "${S22_NUM}" ]]; then
                  activate_issue "${S22_NUM}"
                else
                  echo "WARNING: Step.2.2 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.2")
              # Step.2.2 完了 → Step.2.3 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S23_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.3:')
                if [[ -n "${S23_NUM}" ]]; then
                  activate_issue "${S23_NUM}"
                else
                  echo "WARNING: Step.2.3 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.3")
              # Step.2.3 完了 → Step.2.4 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S24_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.4:')
                if [[ -n "${S24_NUM}" ]]; then
                  activate_issue "${S24_NUM}"
                else
                  echo "WARNING: Step.2.4 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.4")
              # Step.2.4 完了 → Step.2.5 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S25_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.5:')
                if [[ -n "${S25_NUM}" ]]; then
                  activate_issue "${S25_NUM}"
                else
                  echo "WARNING: Step.2.5 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.5")
              # Step.2.5 完了 → Step.2.6 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                S26_NUM=$(get_sub_issue_number_from_parent "${S2_NUM}" '\[ASDW\] Step\.2\.6:')
                if [[ -n "${S26_NUM}" ]]; then
                  activate_issue "${S26_NUM}"
                else
                  echo "WARNING: Step.2.6 が見つかりません。"
                fi
              else
                echo "WARNING: Step.2 コンテナが見つかりません。"
              fi
              ;;

            "2.6")
              # Step.2.6 完了 → Step.2 コンテナに asd:done → Step.3.1 を起動
              S2_NUM=$(get_sub_issue_number '\[ASDW\] Step\.2:')
              if [[ -n "${S2_NUM}" ]]; then
                add_label "${S2_NUM}" "asd:done"
                echo "Step.2 コンテナに asd:done を付与しました。"
              fi
              S3_NUM=$(get_sub_issue_number '\[ASDW\] Step\.3:')
              if [[ -n "${S3_NUM}" ]]; then
                S31_NUM=$(get_sub_issue_number_from_parent "${S3_NUM}" '\[ASDW\] Step\.3\.1:')
                if [[ -n "${S31_NUM}" ]]; then
                  activate_issue "${S31_NUM}"
                else
                  echo "WARNING: Step.3.1 が見つかりません。"
                fi
              else
                echo "WARNING: Step.3 コンテナが見つかりません。"
              fi
              ;;

            "3.1")
              # Step.3.1 完了 → Step.3.2 を起動
              S3_NUM=$(get_sub_issue_number '\[ASDW\] Step\.3:')
              if [[ -n "${S3_NUM}" ]]; then
                S32_NUM=$(get_sub_issue_number_from_parent "${S3_NUM}" '\[ASDW\] Step\.3\.2:')
                if [[ -n "${S32_NUM}" ]]; then
                  activate_issue "${S32_NUM}"
                else
                  echo "WARNING: Step.3.2 が見つかりません。"
                fi
              else
                echo "WARNING: Step.3 コンテナが見つかりません。"
              fi
              ;;

            "3.2")
              # Step.3.2 完了 → Step.3 コンテナに asd:done → Step.4.1 + Step.4.2 を並列起動
              S3_NUM=$(get_sub_issue_number '\[ASDW\] Step\.3:')
              if [[ -n "${S3_NUM}" ]]; then
                add_label "${S3_NUM}" "asd:done"
                echo "Step.3 コンテナに asd:done を付与しました。"
              fi
              S4_NUM=$(get_sub_issue_number '\[ASDW\] Step\.4:')
              if [[ -n "${S4_NUM}" ]]; then
                S41_NUM=$(get_sub_issue_number_from_parent "${S4_NUM}" '\[ASDW\] Step\.4\.1:')
                S42_NUM=$(get_sub_issue_number_from_parent "${S4_NUM}" '\[ASDW\] Step\.4\.2:')
                if [[ -n "${S41_NUM}" ]]; then
                  activate_issue "${S41_NUM}"
                  echo "Step.4.1 を起動しました（並列実行）。"
                else
                  echo "WARNING: Step.4.1 が見つかりません。"
                fi
                if [[ -n "${S42_NUM}" ]]; then
                  activate_issue "${S42_NUM}"
                  echo "Step.4.2 を起動しました（並列実行）。"
                else
                  echo "WARNING: Step.4.2 が見つかりません。"
                fi
              else
                echo "WARNING: Step.4 コンテナが見つかりません。"
              fi
              ;;

            "4.1"|"4.2")
              # Step.4.1 or Step.4.2 完了 → 両方完了確認 → Step.4 コンテナに asd:done → Root に asd:done + 完了コメント
              S4_NUM=$(get_sub_issue_number '\[ASDW\] Step\.4:')
              if [[ -n "${S4_NUM}" ]]; then
                # Step.4.1 と Step.4.2 の両方が asd:done かチェック
                S4_SUBS=$(api_call GET \
                  "https://api.github.com/repos/${REPO}/issues/${S4_NUM}/sub_issues")
                BOTH_DONE=$(echo "${S4_SUBS}" | python3 /dev/fd/3 3<<'PY'
          import sys, json
          issues = json.load(sys.stdin)
          # Step.4.1 と Step.4.2 の label に asd:done が含まれるか確認
          done_count = 0
          for issue in issues:
              labels = [l['name'] for l in issue.get('labels', [])]
              if 'asd:done' in labels:
                  done_count += 1
          # 両方(2つ)が done なら true
          print('true' if done_count >= 2 else 'false')
          PY
                )
                if [[ "${BOTH_DONE}" == "true" ]]; then
                  add_label "${S4_NUM}" "asd:done"
                  echo "Step.4 コンテナに asd:done を付与しました。"
                  # Root Issue に asd:done を付与してパイプライン完了を示す
                  add_label "${ROOT_ISSUE}" "asd:done"
                  echo "Root Issue #${ROOT_ISSUE} に asd:done を付与しました。"
                  # Root Issue に完了コメント
                  post_comment "${ROOT_ISSUE}" "🎉 全ての開発ステップが完了しました！Root Issue #${ROOT_ISSUE} の Web App on Azure 開発パイプラインが正常に終了しました。"
                  echo "Root Issue #${ROOT_ISSUE} に完了コメントを投稿しました。"
                else
                  echo "Step.4 の両方の Sub Issue がまだ完了していません。もう一方の完了を待ちます。"
                fi
              else
                echo "WARNING: Step.4 コンテナが見つかりません。"
              fi
              ;;

            *)
              echo "未定義の Step: ${STEP_MATCH}。スキップ。"
              ;;
          esac
